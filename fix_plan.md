```plaintext
### 1. 何が起きているか ― KO ケース別の現象と直接原因
| カテゴリ | 失敗例                 | 現象 (期待 → 実際)                               | 原因 |
|---------|-----------------------|-------------------------------------------------|------|
| **%c**  | " %c %c %c "
  '0', 0, '1' | 期待:  " 0 \u2423 1 "（長さ 7）
  実際: " 0 0 0 "（長さ 7） | **va_list の進め方を誤り、常に 1 番目の引数を再読** |
| **%s**  | " %s %s "  "", "-"   | 2 本目以降の文字列が空文字 or 1 本目のコピーに化ける | 同上 |
| **%p**  | " %p %p "  LONG_MIN, LONG_MAX | 2 本目以降がすべて 0x8000… になる     | **引数を unsigned long long で受け取り UB 発生** |
| **%d/%i/%u/%x** | " %d %d %d …" 等 | 先頭値を全スロットに繰り返し表示     | **va_list の位置が進んでいない** ＋ 8 byte 整列崩れ |
| **mix** | 大量のフォーマット       | SIGSEGV                                        | 上記 2 点が混在しスタック破壊         |

### 2. 技術的な根本原因
1. **va_list を「値渡しのコピー」でしか操作していない**
   ```c
   w_ret = ft_printf_switch(format, &ap, fd);   // &ap は OK
   // しかし ft_printf_switch 内で …
   va_arg(*ap, int);  // *ap はコピーなので外側の ap には反映されない
   ```
   `va_arg` は *ap の実体* をインクリメントするが、`*ap` で取り出した“コピー”に対して行うため、外側のシーケンスは更新されない。その結果、毎回 1 番目の引数が読まれ続ける。

2. **%p の読み出し型ミス**
   可変長引数には **void*** が渡される。現在は
   ```c
   va_arg(*ap, unsigned long long)
   ```
   で取得しており、サイズ・整列が一致しないため UB → 読み値が壊れる（常に下位 or 上位 4 byte を読む）。

### 3. 修正方針（概要）
| 項目 | 修正内容 |
|------|----------|
| **A. va_list の正しい受け渡し** | - `ft_printf_switch()` には **va_list* を渡す**までは同じだが、*ap をコピーせず**そのまま lvalue**として `va_arg` する。
  → `va_arg((*ap), T)` のように括弧を付けて **lvalue** を保証。 |
| **B. %p の取得型変更** | - `case 'p':`：`void *ptr = va_arg(*ap, void *);`
  - 変換部では `uintptr_t` にキャストして 16 進文字列化。 |
| **C. 付随の型安全性** | - `ft_strlen()` を `size_t` 返値に修正（現在 `int`）。
  - 変換関数の内部計算をすべて `size_t`／`unsigned long long` に統一。 |

### 4. 実装計画書
| # | タスク                      | 変更ファイル                           | 詳細                                                                                                                                     | 評価基準                                 |
|---|----------------------------|---------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------|
| 1 | **va_list 受け渡し修正**      | `ft_printf.h`, `ft_printf_switch.c`, `ft_vprintf.c`, `ft_vdprintf.c` | 1) `ft_printf_switch` の第 2 引数を `va_list *ap` のままにする。
2) **`va_arg((*ap), T)` と括弧付きで呼ぶ**
3) 呼び出し側は `&ap` を 1 回だけ計算し回す。 | printfTester の `%c/%s/%d/%u/%x` 全 KO → OK    |
| 2 | **%p 型修正**               | `ft_printf_switch.c`, `ft_fputp.c`     | - `void *raw = va_arg((*ap), void *);`
- `uintptr_t n = (uintptr_t)raw;`
- 既存変換関数へ渡す。                                                                 | `%p` の 4 ケースが OK                     |
| 3 | **ft_strlen の size_t 化**   | `includes/libft.h`, `src/libft/ft_strlen.c` | 返値型を `size_t` へ、呼び出し箇所は暗黙変換のためコード変更ほぼ不要                                                                   | ビルド警告 0                              |
| 4 | **境界テスト追加**           | `tester` or `main.c`                  | - NUL 文字を含む `%c` 連打
- LONG_MAX/LONG_MIN を混在させた `%d` 連打                                                                  | 追加テストでも全 OK                       |
| 5 | **リファクタ & クリーン**     | all                                   | - `#include <stdint.h>` 追加
- コメント整理、norm コンパイル                                                                                                     | `make re && ./tester` green               |
| 6 | **レビュー & デプロイ**       | —                                     | - コードレビュー（ペア）
- Git tag `fix_va_list_p`                                                                                                     | Merge & tag                             |

**工数見積**
| 作業                   | 時間   |
|----------------------|------|
| コード変更 & コンパイル       | 1 h   |
| 追加テスト / Debug         | 1 h   |
| レビュー & ドキュメント      | 0.5 h |
| **計**                  | **2.5 h** |

### 5. 期待される結果
- printfTester “Mandatory” セクション **全パス**
- Mix ケースの SIGSEGV 消滅
- 自作テスト（NUL 文字・巨大整数・NULL 文字列）でも glibc と **完全一致**
```

